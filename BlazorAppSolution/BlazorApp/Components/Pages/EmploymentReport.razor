@page "/employmentreport"
<PageTitle>Report</PageTitle>
@rendermode InteractiveServer
@using OOPsReview;

<h3>Employment Report</h3>
<br/><br/>
@if (feedback.Length > 0)
{
    <div class="alert alert-info">
        <p>@feedback</p>
    </div>
}
@if (errormsgs.Count > 0)
{
    <div class="alert alert-danger">
        <p>Please fix the following issues:</p>
        <ul>
            @foreach (var error in errormsgs)
            {
                <!--
                    due to the structure of a Dictionary entry
                    there are two components: Key and Value
                    we need to use the Value

                    if this was a List collection there is only
                    one component, the string
                    therefore you would NOT need the .Value
                -->
                <li>@error</li>
            }
        </ul>
    </div>
}

@code {
    private string feedback = "";
    //in this example we will use a List<string> instead of a dictionary
    private List<string> errormsgs = new List<string>();

    private Employment employment = new();
    private List<Employment> employments = null;

    protected override void OnInitialized()
    {
        Reading();
        base.OnInitialized();
    }

    private void Reading()
    {
        feedback = ""; //clear out any old message
        errormsgs.Clear(); //clear out all existing keys and their values

        //there are a couple of ways to refer to your file and its path
        //  i) obtain the root path of your application using an injection
        //      service called IWebHostEnvironment via property injection (see variables)
        //  ii) use relative addressing starting a the top of your application

        //on this page we will use relative addressing
        //This addressing of the required file will start at the top of your web application
        //syntax:   string filename = @"./foldername/.../filename.csv"
        string filename = @"./Data/Employements.csv";

        // The System.IO.File method ReadAllLines(...) will return an array
        //      of lines as strings where each array element represents a
        //      line in my file
        Array userdata = null;
        try
        {
            //read the file
            userdata = System.IO.File.ReadAllLines(filename);

        //the records at this point are just strings
        //the records need to be turned into instances of Employment
        //then each instance will be added to the collection for the report
            foreach (string line in userdata)
            {
                
            }
        }
        catch (ArgumentNullException ex)
        {
            errormsgs.Add(GetInnerException(ex).Message);
        }
        catch (ArgumentOutOfRangeException ex)
        {
            errormsgs.Add(GetInnerException(ex).Message);
        }
        catch (ArgumentException ex)
        {
            errormsgs.Add(GetInnerException(ex).Message);
        }
        catch (Exception ex)
        {
            errormsgs.Add(GetInnerException(ex).Message);
        }
    }

    private Exception GetInnerException(Exception ex)
    {
        //drill down into your Exception until there are no more inner exceptions
        //at this point you have the "real" error
        while (ex.InnerException != null)
            ex = ex.InnerException;
        return ex;
    }

}
